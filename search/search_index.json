{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#fastapi-jwt","title":"fastapi-jwt","text":"<p>FastAPI native extension, easy and simple JWT auth</p> <p>Documentation: k4black.github.io/fastapi-jwt Source Code: github.com/k4black/fastapi-jwt</p>"},{"location":"#features","title":"Features","text":"<ul> <li>OpenAPI schema generation </li> <li>Native integration with FastAPI</li> <li>Access/Refresh JWT</li> <li>JTI</li> <li>Cookie setting</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can access package fastapi-jwt in pypi <pre><code>pip install fastapi-jwt\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>This library made in fastapi style, so it can be used as standard security features </p> <pre><code>from fastapi import FastAPI, Security, Response\nfrom fastapi_jwt import JwtAuthorizationCredentials, JwtAccessBearer\n\n\napp = FastAPI()\naccess_security = JwtAccessBearer(secret_key=\"secret_key\", auto_error=True)\n\n\n@app.post(\"/auth\")\ndef auth():\n    subject = {\"username\": \"username\", \"role\": \"user\"}\n    return {\"access_token\": access_security.create_access_token(subject=subject)}\n\n@app.post(\"/auth_cookie\")\ndef auth(response: Response):\n    subject = {\"username\": \"username\", \"role\": \"user\"}\n    access_token = access_security.create_access_token(subject=subject)\n    access_security.set_access_cookie(response, access_token)\n    return {\"access_token\": access_token}\n\n\n@app.get(\"/users/me\")\ndef read_current_user(\n    credentials: JwtAuthorizationCredentials = Security(access_security),\n):\n    return {\"username\": credentials[\"username\"], \"role\": credentials[\"role\"]}\n</code></pre> <p>For more examples see usage docs</p>"},{"location":"#alternatives","title":"Alternatives","text":"<ul> <li>FastAPI docs suggest writing it manually, but</li> <li>code duplication  </li> <li> <p>opportunity for bugs</p> </li> <li> <p>There is nice fastapi-jwt-auth, but</p> </li> <li>poorly supported  </li> <li>not \"FastAPI-style\" (not native functions parameters)</li> </ul>"},{"location":"#fastapi-integration","title":"FastAPI Integration","text":"<p>There it is open and maintained Pull Request #3305 to the <code>fastapi</code> repo. Currently, not considered.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li><code>fastapi</code></li> <li><code>python-jose[cryptography]</code></li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-fastapi-jwt","title":"Contributing to fastapi-jwt","text":"<p>First, thanks for taking the time to contribute! \ud83d\ude0d It's highly welcomed, and it can help the project to develop and become more usefully and suitable for everyone. </p>"},{"location":"contributing/#styleguides","title":"Styleguides","text":""},{"location":"contributing/#git-commit-messages","title":"Git Commit Messages","text":"<p>This project uses light version of conventional commits.  tl;dr</p> <ul> <li>Use the present tense (\"Add feature\" not \"Added feature\")</li> <li>Use the imperative mood (\"Move cursor to...\" not \"Moves cursor to...\")</li> <li>Limit the first line to 72 characters or less</li> <li>Reference issues and pull requests in commit body</li> <li>When only changing documentation, include [ci skip] in the commit title</li> <li>Consider starting the commit message with an applicable tag:<ul> <li><code>fix</code> - small bug fix</li> <li><code>docs</code> - docs changes </li> <li><code>feat</code> - a new feature </li> <li><code>chore</code> - changes that do not relate to a fix or feature and don't modify src or test files (for example updating dependencies) </li> <li><code>refactor</code> - code refactor that neither fixes a bug nor adds a feature</li> <li><code>style</code> - changes that do not affect the meaning of the code</li> <li><code>perf</code> - changes that improve performance</li> <li><code>test</code> - including new or correcting previous tests</li> <li><code>ci</code> - continuous integration related</li> </ul> </li> </ul> <p>For example  </p> <p>Good: * <code>feat: create new api endpoint for student scores reporting</code> * <code>perf: improve performance with lazy load implementation for images</code> * <code>chore: update flask dependency to 2.1 version</code></p> <p>Bad: * <code>some fixes</code> * <code>oops</code> * <code>fixed bug on landing page</code> * <code>style changes and update</code></p>"},{"location":"contributing/#python-styleguide","title":"Python styleguide","text":"<p>All python code should follow PEP8 and be typed.  The code linted with <code>flake8</code> and <code>isort</code>, as well as type checked with <code>mypy</code>.</p> <p>TBA</p>"},{"location":"developing/","title":"Developing","text":"<p>Recommend to use venv for development. <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre></p> <p>Install dev dependencies  <pre><code>python -m pip install .[docs,test]  # \\[docs,test\\] in zsh\n</code></pre></p>"},{"location":"developing/#python-package","title":"Python package","text":""},{"location":"developing/#linting-and-testing","title":"Linting and Testing","text":"<p>It is important NOT ONLY to get OK from all linters (or achieve score in the case of pylint), but also to write good code.   P.S. It's hard to say what a Good Code is. Let's say that it should be simple, clear, commented, and so on. <pre><code>python -m flake8 .\npython -m mypy fastapi_jwt\npython -m isort . --check\n</code></pre></p> <p>Try NOT ONLY to achieve 100% coverage, but also to cover extreme cases, height load cases, multithreaded cases, incorrect input, and so on. <pre><code>python -m pytest\n</code></pre></p> <p>You can fix some issues in auto mode.</p> <ul> <li>Sorting imports and make autopep.     <pre><code>python -m isort .\n</code></pre></li> </ul>"},{"location":"developing/#publishing","title":"Publishing","text":"<p>Egg (deprecated)  <pre><code>python3 setup.py build\npython3 setup.py sdist\ntwine upload -r testpypi dist/*\ntwine upload dist/*\n</code></pre></p> <p>Build Wheel and see what inside <pre><code>python3 -m pip wheel . --no-deps --wheel-dir dist\ntar --list -f dist/fastapi-jwt-0.0.1-py3-none-any.whl  </code></pre></p> <p>Load dist to pypi <pre><code>twine upload -r testpypi dist/*\ntwine upload dist/*\n</code></pre></p>"},{"location":"developing/#docs","title":"Docs","text":""},{"location":"developing/#editing","title":"Editing","text":"<p>Edit it in <code>docs/</code></p> <p><code>mkdocs</code> can be run as dev server with auto-reload. <pre><code>mkdocs serve --config-file docs/mkdocs.yml\n</code></pre></p> <p>Note: Server will auto-restart for all changed <code>docs/*</code> files. If you want to edit <code>README.md</code> or <code>CONTRIBUTING.md</code> you should restart server on each change.  </p>"},{"location":"developing/#building-pkg-docs-todo","title":"Building pkg docs (<code>TODO</code>)","text":"<p>Add python backend docs <code>TODO</code> <pre><code>lazydocs \\\n--output-path=\"./docs/references/backend\" \\\n--overview-file=\"index.md\" \\\n--src-base-url=\"https://github.com/k4black/flowingo/blob/master\" \\\nflowingo\n</code></pre></p>"},{"location":"developing/#deploy","title":"Deploy","text":""},{"location":"developing/#without-versioning-now","title":"Without versioning (now)","text":"<p>Build and deploy docs itself <pre><code>mkdocs build --config-file docs/mkdocs.yml\nmkdocs gh-deploy --config-file docs/mkdocs.yml    </code></pre></p>"},{"location":"developing/#with-mike-as-versioning-tool-todo","title":"With <code>mike</code> as versioning tool (<code>TODO</code>)","text":"<p>Deploy with <code>mike</code> to github-pages with versioning support <pre><code>mike deploy --config-file docs/mkdocs.yml 0.0.1 latest --push\nmike alias --config-file docs/mkdocs.yml 0.0.1 0.0.x --push\nmike set-default --config-file docs/mkdocs.yml latest --push\n</code></pre></p>"},{"location":"developing/#with-read-the-docs-as-versioning-tool-todo","title":"With <code>read-the-docs</code> as versioning tool (<code>TODO</code>)","text":"<p>Deploy with <code>mkdocs</code> to read-the-docs for versioning support <pre><code>TODO\n</code></pre></p>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#changelog","title":"Changelog","text":""},{"location":"release-notes/#latest-changes","title":"Latest Changes","text":""},{"location":"user_guide/classes/","title":"Classes","text":"<p>This library made in fastapi style, so it can be used as standard security features </p>"},{"location":"user_guide/classes/#security-classes","title":"Security classes","text":""},{"location":"user_guide/classes/#credentials","title":"Credentials","text":"<ul> <li><code>JwtAuthorizationCredentials</code> - universal credentials for access and refresh tokens.     Provide access to subject and unique token identifier (jti)     <pre><code>def foo(credentials: JwtAuthorizationCredentials = Security(access_security)):\n    return credentials[\"username\"], credentials.jti\n</code></pre></li> </ul>"},{"location":"user_guide/classes/#access-tokens","title":"Access tokens","text":"<ul> <li><code>JwtAccessBearer</code> - read access token from bearer header only</li> <li><code>JwtAccessCookie</code> - read access token from cookies only</li> <li><code>JwtAccessBearerCookie</code> - read access token from both bearer and cookie</li> </ul>"},{"location":"user_guide/classes/#refresh-tokens","title":"Refresh tokens","text":"<ul> <li><code>JwtRefreshBearer</code> - read access token from bearer header only</li> <li><code>JwtRefreshCookie</code> - read access token from cookies only</li> <li><code>JwtRefreshBearerCookie</code> - read access token from both bearer and cookie</li> </ul>"},{"location":"user_guide/classes/#create","title":"Create","text":"<p>You can create <code>access_security</code> / <code>refresh_security</code> in multiple ways  <pre><code># Manually\naccess_security = JwtAccessBearerCookie(\n    secret_key=\"other_secret_key\",\n    auto_error=True,\n    access_expires_delta=timedelta(hours=1),  # custom access token valid timedelta\n    refresh_expires_delta=timedelta(days=1),  # custom access token valid timedelta\n)\n\n# Create from another object, copy all params\nrefresh_security = JwtRefreshBearer.from_other(access_security)\n\n# Create from another object, rewrite some params\nother_access_security = JwtAccessCookie.from_other(\n    access_security, \n    secret_key='!key!', \n    auto_error=False\n)\n</code></pre></p>"},{"location":"user_guide/examples/","title":"Examples","text":"<p>This library made in fastapi style, so it can be used as standard security features </p>"},{"location":"user_guide/examples/#full-example","title":"Full Example","text":"<pre><code>from datetime import timedelta\n\nfrom fastapi import FastAPI, Security, HTTPException\nfrom fastapi_jwt import (\n    JwtAccessBearerCookie,\n    JwtAuthorizationCredentials,\n    JwtRefreshBearer,\n)\n\n\napp = FastAPI()\n\n\n# Read access token from bearer header and cookie (bearer priority)\naccess_security = JwtAccessBearerCookie(\n    secret_key=\"secret_key\",\n    auto_error=False,\n    access_expires_delta=timedelta(hours=1)  # change access token validation timedelta\n)\n# Read refresh token from bearer header only\nrefresh_security = JwtRefreshBearer(\n    secret_key=\"secret_key\", \n    auto_error=True  # automatically raise HTTPException: HTTP_401_UNAUTHORIZED \n)\n\n\n@app.post(\"/auth\")\ndef auth():\n    # subject (actual payload) is any json-able python dict\n    subject = {\"username\": \"username\", \"role\": \"user\"}\n\n    # Create new access/refresh tokens pair\n    access_token = access_security.create_access_token(subject=subject)\n    refresh_token = refresh_security.create_refresh_token(subject=subject)\n\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\ndef refresh(\n        credentials: JwtAuthorizationCredentials = Security(refresh_security)\n):\n    # Update access/refresh tokens pair\n    # We can customize expires_delta when creating\n    access_token = access_security.create_access_token(subject=credentials.subject)\n    refresh_token = refresh_security.create_refresh_token(subject=credentials.subject, expires_delta=timedelta(days=2))\n\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.get(\"/users/me\")\ndef read_current_user(\n        credentials: JwtAuthorizationCredentials = Security(access_security)\n):  \n    # auto_error=False, fo we should check manually\n    if not credentials:\n        raise HTTPException(status_code=401, detail='my-custom-details')\n\n    # now we can access Credentials object\n    return {\"username\": credentials[\"username\"], \"role\": credentials[\"role\"]}\n</code></pre>"}]}